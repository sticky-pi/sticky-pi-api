# temporary API methods to work with mock master projects metadata data.table

# Note: for all below, arbitrary proj_id for now, real proj_id will be generated by SQL DB
#   do not include proj_id in "fields" args
# add row to master projects record table: {proj_id, name, description, notes}
# add row to master permissions table: {proj_id, username, level}
#   level can be 0, 1, or 2,
#       0: read only,
#       1: read, write
#       2: read, write, admin(manage members, delete proj)
# will be back/mid-end for webapp create new project interface
put_project <- function(fields) {
    proj_id <- 0
    if ((PROJECTS_RECORD[,.N]) != 0) {
        # ids all just increment by 1 each row
        proj_id <- PROJECTS_RECORD[, max(project_id)] + 1
    }

    # NOTE: below assignments use global <<-
    # when translate to Python, actually update orig SQL tables
    proj_row <- data.table(project_id = proj_id,
                           name = fields[["name"]],
                           description = fields[["description"]],
                           notes = fields[["notes"]]
                        )
    PROJECTS_RECORD <<- rbindlist(list( PROJECTS_RECORD, proj_row ))

    # creator must be an admin
    PERMISSIONS_TABLE <<- rbindlist(list( PERMISSIONS_TABLE,
                                      data.table(project_id = proj_id,
                                                 username = CURRENT_USERNAME,
                                                 level = 2 )
                                      ))
}

# return meta-info of all the projects the user has read access to
get_projects <- function() {
    accessible_projs_ids <- PERMISSIONS_TABLE[username == CURRENT_USERNAME & level >= 0, project_id]
    PROJECTS_RECORD[project_id %in% accessible_projs_ids]
}

# replace the current project record entry with data(a list): {project_id, name, description, notes}
# matched by project ID
update_project <- function(data) {
    proj_id <- data$project_id

    # first check if empty
    if (PERMISSIONS_TABLE[project_id == proj_id & username == CURRENT_USERNAME, .N] == 0) {
        cat("no permission to delete project or project not found, empty")
    }
    # check write access
    else if (PERMISSIONS_TABLE[project_id == proj_id & username == CURRENT_USERNAME, level] >= 1)
    {
        PROJECTS_RECORD[project_id == proj_id, names(PROJECTS_RECORD) := data]
    }
    else {
        cat("no permission to delete project or project not found")
    }
}

delete_project <- function(proj_id) {
    # check write access
    if (PERMISSIONS_TABLE[project_id == proj_id & username == CURRENT_USERNAME, level] == 2)
    {
        # implementation here "temporary", handled by SQL
        PROJECTS_RECORD <<- PROJECTS_RECORD[project_id != proj_id]
        PERMISSIONS_TABLE <<- PERMISSIONS_TABLE[project_id != proj_id]
    }
    else {
        cat("no permission to delete project or project not found")
    }
}
